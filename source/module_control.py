import os
from shutil import copy2, move
import tkinter.messagebox
from tkinter.filedialog import askopenfilename, askopenfilenames, askdirectory
from tkinter.simpledialog import askstring
from datetime import datetime
import xxhash
from glob import glob
import json

import source.shared as s


SNAPSHOT_DIRECTORY = './snapshots'
SNAPSHOT_COMPARISON_DIRECTORY = './snapshot_comparisons'
COMPARISON_NAME = 'comparison_'

TRANSFER_TYPES = [
    'move',
    'copy',
    'delete',
]
DEFINITION_NAME = '_definition.json'
DEFINITION_CLASSES = ['General', 'Clone', 'Foundling', 'Template']
DEFINITION_CLASS_TEMPLATE = {
    'comment': "// do not edit this file by hand. Use the 'edit definition' option in the application\n",
    'class': '',
    'name': '',
    'game': '',
    'active': False,
    'progress': '',
    'ancestor': '',
    'heir': '',
    'description': '',
    'changes': {}
}
PRINT_COLORS = {
    'information': '\033[96m',
    'warning': '\033[93m',
    'error': '\033[91m',
    'end': '\033[0m',
}


def log(output):
    """ Saves the given text into the main change log. """
    text = ''
    if TEST:
        for importance_level in PRINT_COLORS[:-1]:
            if importance_level in output:
                text = (output[:output.index(importance_level)] + PRINT_COLORS[importance_level] + importance_level
                        + PRINT_COLORS['end'] + output[output.index(importance_level) + len(importance_level):])
        if text:
            print(text)
        else:
            print(output)
    else:
        date = str(datetime.now()) + '\t'
        if not os.path.isdir(s.LOG_PATH):
            os.mkdir(s.LOG_PATH)
        try:
            with open(f'{s.LOG_PATH}/main_change_log.txt', 'a') as log_buffer:
                log_buffer.write(date + output + '\n')
        except FileNotFoundError:
            with open(f'{s.LOG_PATH}/main_change_log.txt', 'w') as log_buffer:
                log_buffer.write(date + output + '\n')
    return output


class Definition(dict):
    """ A dictionary-based class with predefined keys and functions that manipulate modules. """
    def __init__(self):
        super().__init__()
        for key in DEFINITION_CLASS_TEMPLATE:
            try:
                self[key] = DEFINITION_CLASS_TEMPLATE[key].copy()
            except AttributeError:
                self[key] = DEFINITION_CLASS_TEMPLATE[key]

    def edit(self, **key_args):
        return definition_edit(self, **key_args)

    def retrieve(self):
        try:
            module_reverse(module_object=self, transfer='remove')
            return True
        except s.InternalError:
            return False

    def attach(self):
        try:
            module_attach(self)
            return True
        except s.InternalError:
            try:
                module_attach(module_directory=f"{s.LIBRARY}/{self['name']}")
                return True
            except s.InternalError:
                # module_attach(module_directory=self['path'])
                return True

    def reload(self):
        if self.retrieve():
            if self.attach():
                return True
            else:
                return False
        else:
            return False

    def reload_after_class_change(self):
        if self['class'] == DEFINITION_CLASSES[0]:
            module_reverse(self, transfer='delete', check_type='pass')
            module_attach(self)
        if self['class'] == DEFINITION_CLASSES[1]:
            module_reverse(self, transfer='copy', check_type='pass')
            module_attach(self)

    def extract(self):
        module_reverse(module_object=self, transfer='copy')


DEFINITION_EXAMPLE = Definition()


def definition_write(definition_object=None, module_directory=None, return_type='object', changes_source='directory',
                     **key_args):
    """
    Reads a definition and formats it into text, that can be saved into a text file.
    :param definition_object: (optional) a definition dictionary-like object
    :param module_directory: (optional) a path to identify a module and to save the definition to
    :param return_type: 'object' (+) 'save' - if 'object', returns a definition dictionary-like object.
    If 'text save' or 'object save', saves the definition into a file.
    :param changes_source: (optional) 'directory' | 'snapshot' | 'comparison' | >the directory to base it upon<
    - passed to initiate_comparison
    :param key_args: (optional) key - arguments pairs for values to change before saving.
    :return: according to the return_type
    """
    if module_directory is None:
        if definition_object is None:
            module_directory = askdirectory(title=f'{s.PROGRAM_NAME}: select the directory to define as a module',
                                            initialdir=s.LIBRARY)
            if not module_directory:
                raise s.InternalError('directory not selected')
        elif os.path.isdir(f"{s.LIBRARY}/{definition_object['name']}"):
            module_directory = f"{s.LIBRARY}/{definition_object['name']}"
    if definition_object is not None:
        module_name = definition_object['name']
    elif module_directory is not None:
        module_name = module_directory.split('/')[-1]
    else:
        module_name = 'default name'
    if definition_object is None:
        if os.path.isfile(f'{module_directory}/{DEFINITION_NAME}'):
            definition_object = definition_read(module_path=f'{module_directory}')
        else:
            definition_object = Definition()
    try:
        if not definition_object['game'] and os.path.isdir(module_directory):
            game_folders = os.listdir(module_directory)
            for folder in game_folders:
                if os.path.isdir(f'../{folder}'):
                    definition_object['game'] = folder
                    break
            if not definition_object['game']:
                definition_object['game'] = module_name.split('-')[0]
    except IndexError:
        pass
    if not definition_object['name'] and module_directory:
        definition_object['name'] = module_directory.split('/')[-1]
    if 'ancestor' in key_args:
        definition_object['ancestor'] = key_args['ancestor']
    if 'heir' in key_args:
        definition_object['heir'] = key_args['heir']
    if not definition_object['changes']:
        try:
            definition_object['active'], definition_object['changes'] = initiate_comparison(
                module_directory, changes_source=changes_source)
        except s.InternalError:
            pass
    if 'save' in return_type:
        with open(f'{module_directory}/{DEFINITION_NAME}', 'w') as definition_buffer:
            json.dump(definition_object, definition_buffer, indent=4)
            log(f'definition saved in {module_directory}')
    elif 'object' in return_type:
        return definition_object


def definition_read(module_path=None):
    """
    Reads the definition of an object and loads it into a dictionary.
    :param module_path: (optional) a module path to check if a definition file exists
    :return: a definition dictionary-like class
    """
    if module_path is not None:
        if module_path in s.current[s.KEY_EXCEPTIONS]:
            raise s.InternalError("the provided path is defined as exception")
    if module_path is None or module_path == "":
        module_path = askdirectory(title=f'{s.PROGRAM_NAME}: select the module directory',
                                   initialdir=s.LIBRARY)
        if module_path == "":
            raise s.InternalError('directory not selected')
    if os.path.exists(f'{module_path}/{DEFINITION_NAME}'):
        with open(f'{module_path}/{DEFINITION_NAME}') as definition_buffer:
            return json.load(definition_buffer)
    else:
        return Definition()


def definition_edit(definition_object=None, module_path=None, **key_args):
    """
    Edits parameters of a Definition object
    :param definition_object: (optional) a Definition object to edit
    :param module_path: (optional) the path to a module with a definition file.
    :param key_args: key - arguments pairs of parameters to changes.
    :return: the edited Definition object.
    """
    if definition_object is None:
        if module_path is None:
            module_path = askdirectory(title=f'{s.PROGRAM_NAME}: select the module directory',
                                       initialdir=s.LIBRARY)
        if module_path:
            definition_object = definition_read(module_path=module_path)
        if not definition_object:
            raise s.InternalError('definition missing')
    else:
        if module_path is None:
            module_path = f"{s.LIBRARY}/{definition_object['name']}"
    for key in key_args:
        if key in DEFINITION_EXAMPLE:
            if key == 'name':
                list_modules = modules_filter(return_type='names')
                for module_name in list_modules:
                    if key_args['name'] == module_name:
                        raise s.InternalError('definition_edit: name already in use')
                for module_name in list_modules:
                    module_definition = definition_read(module_path=f'{s.LIBRARY}/{module_name}')
                    if definition_object['name'] == module_definition['ancestor']:
                        definition_edit(
                            module_definition,
                            ancestor=module_definition['ancestor'].replace(definition_object['name'], key_args['name'])
                        )
                    if definition_object['name'] == module_definition['heir']:
                        definition_edit(
                            module_definition,
                            heir=module_definition['heir'].replace(definition_object['name'], key_args['name'])
                        )
                os.rename(src=module_path, dst=f"{'/'.join(module_path.split('/')[:-1])}/{key_args['name']}")
            definition_object[key] = key_args[key]
        else:
            raise s.InternalWarning(f'key {key} not recognized')
    return definition_write(definition_object, return_type='object save')


# TODO: check if correct business logic
def detect_new_modules():
    output = ''
    library_folders = [_ for _ in os.listdir(s.LIBRARY) if _ not in s.current[s.KEY_EXCEPTIONS]]
    for folder in library_folders:
        if not os.path.isfile(f'{s.LIBRARY}/{folder}/{DEFINITION_NAME}'):
            output += f'Registering a definition-less folder in the library - {folder}\n'
    return output


def hash_file(file_path):
    """ Returns the hash value of a file. Non-cryptographic 128 hexadecimal hash value. """
    with open(file_path, 'rb') as file_buffer:
        file_content = file_buffer.read()
    hash_value = xxhash.xxh128(file_content).hexdigest()
    return hash_value


def hash_directory(file_or_folder, path_to_omit=''):
    """ Composes a text where every file of a given directory is listed with its hash value. """
    output = {}
    if os.path.isfile(file_or_folder):
        if path_to_omit:
            path_to_register = file_or_folder[file_or_folder.index(path_to_omit) + len(path_to_omit) + 1:]
        else:
            path_to_register = file_or_folder
        output[os.path.relpath(path_to_register).replace('\\', '/')] = f'\t{hash_file(file_or_folder)}\n'
    elif os.path.isdir(file_or_folder):
        next_directory = os.listdir(file_or_folder)
        for next_folder in next_directory:
            if next_folder in s.current[s.KEY_GAMES]:
                next_directory = [next_folder]
                break
        for next_file_or_folder in next_directory:
            output.update(hash_directory(f'{file_or_folder}/{next_file_or_folder}', path_to_omit=path_to_omit))
    return output


def get_available_name(snapshot_directory, prefix='file_snapshot_'):
    """ Given a directory, returns the name of the next file to save into. """
    counter = 1
    if not os.path.isdir(snapshot_directory):
        os.mkdir(snapshot_directory)
    elif os.path.exists(f'{snapshot_directory}/{prefix}{counter}.json'):
        snapshot_list = glob(f'{snapshot_directory}/{prefix}*.json')
        try:
            suffix = ''
            while not suffix.isnumeric():
                last_snapshot = max(snapshot_list, key=os.path.getctime)
                snapshot_list.remove(last_snapshot)
                suffix = last_snapshot[last_snapshot.index(prefix) + len(prefix):last_snapshot.index('.txt')]
            counter = str(int(suffix) + 1)
        except ValueError:
            counter = askstring(title=f'{s.PROGRAM_NAME}', prompt='Please give a name to the new file')
        except NameError:
            pass
    return f'{snapshot_directory}/{prefix}{counter}.json'


def snapshot_take(game_paths=None, add_paths=False, return_type='path', name=None):
    """
    Takes a snapshot of a selected directory.
    :param game_paths: directory to take a snapshot of.
    :param add_paths: True | False - when True, asks for new directories until cancel is pressed.
    :param return_type: 'path' | 'dict' (+) 'save' - if 'path', returns the path of the file where the snapshot has been saved.
    If 'dict', returns the content.
    :param name:
    :return: according to return-type.
    """
    if game_paths is None:
        game_paths = ['>no_path<']
    game_snapshot = {"date": f"{datetime.now()}"}
    path_to_omit = ''
    for game_path in game_paths:
        if game_path == '>no_path<':
            game_full_path = askdirectory(initialdir=f'{s.MAIN_DIRECTORY}',
                                          title=f'{s.PROGRAM_NAME}: select game directory to take a snapshot of')
            if game_full_path:
                if s.LIBRARY in game_full_path:
                    path_to_omit += '/'.join(game_full_path.split('/')[:s.LIBRARY.count('/') + 2])
                path_to_omit_locally = s.MAIN_DIRECTORY
                game_path = game_full_path[len(path_to_omit_locally):]
                game_paths[game_paths.index('>no_path<')] = game_path
                if add_paths:
                    game_paths.append('>no_path<')
            elif len(game_paths) == 0:
                raise s.InternalError('directory not selected')
        mod_dir = f'{s.MAIN_DIRECTORY}/{game_path}'
        if not os.path.isdir(mod_dir):
            game_paths.remove(game_path)
    for game_path in game_paths:
        if not game_path:
            raise s.InternalError('directory not selected')
        game_snapshot.update(hash_directory(f'{s.MAIN_DIRECTORY}/{game_path}', path_to_omit=path_to_omit))
    if return_type == 'dict':
        log('snapshot_take successful')
        return game_snapshot
    if not name:
        snapshot_path = get_available_name(SNAPSHOT_DIRECTORY)
    elif os.path.isfile(f'{SNAPSHOT_DIRECTORY}/file_snapshot_{name}.json'):
        if os.path.isfile(f'{SNAPSHOT_DIRECTORY}/file_snapshot_{name}-{datetime.now().date()}.json'):
            snapshot_path = f'{SNAPSHOT_DIRECTORY}/file_snapshot_{name}-{datetime.now()}.json'.replace(":", "_")
        else:
            snapshot_path = f'{SNAPSHOT_DIRECTORY}/file_snapshot_{name}-{datetime.now().date()}.json'
    else:
        snapshot_path = f'{SNAPSHOT_DIRECTORY}/file_snapshot_{name}.json'
    with open(snapshot_path, 'w') as snapshot_buffer:
        json.dump(game_snapshot, snapshot_buffer, indent=4)
    log(f'snapshot successfully saved in file {snapshot_path}')
    if 'dict' in return_type:
        return game_snapshot
    elif 'path' in return_type:
        return snapshot_path


def snapshot_compare(snap_anterior=None, snap_posterior=None, return_type='path'):
    """
    Compares two snapshots, determining which files are different, unchanged, new or removed.
    :param snap_anterior: first snapshot to compare to
    :param snap_posterior: second snapshot to compare with
    :param return_type: 'path' | 'lines' - If 'path', returns the path of the file, where the comparison has been saved.
    If 'lines', does not save the result into a file, but returns it.
    :return: according to the return_type.
    """
    dict_anterior = {}
    dict_posterior = {}
    if snap_anterior is None:
        snap_anterior = askopenfilename(title=f'{s.PROGRAM_NAME}: choose the base snapshot to compare with',
                                        initialdir=SNAPSHOT_DIRECTORY)
        if not snap_anterior:
            raise s.InternalError('no snapshot selected')
    if isinstance(snap_anterior, dict):
        dict_anterior = snap_anterior.copy()
        snap_anterior = 'unsaved output'
    elif os.path.isfile(snap_anterior):
        with open(snap_anterior) as file_anterior:
            dict_anterior = json.load(file_anterior)
    if snap_posterior is None:
        snap_posterior = askopenfilename(title=f'{s.PROGRAM_NAME}: choose the second snapshot to compare',
                                         initialdir=SNAPSHOT_DIRECTORY)
        if not snap_posterior:
            raise s.InternalError('no snapshot selected')
    if isinstance(snap_posterior, dict):
        dict_posterior = snap_posterior.copy()
        snap_posterior = 'unsaved output'
    elif os.path.isfile(snap_posterior):
        with open(snap_posterior) as file_posterior:
            dict_posterior = json.load(file_posterior)
    dict_output = {}
    for key_name_anterior in dict_anterior:
        if key_name_anterior == 'date':
            dict_output['date_1'] = f"{snap_anterior} {dict_anterior['date']}"
            dict_output['date_2'] = f"{snap_posterior} {dict_posterior['date']}"
            continue
        try:
            if dict_anterior[key_name_anterior] == dict_posterior[key_name_anterior]:
                dict_output[key_name_anterior] = ['unchanged', dict_anterior[key_name_anterior]]
            else:
                dict_output[key_name_anterior] = ['changed',
                                                  dict_anterior[key_name_anterior],
                                                  dict_posterior[key_name_anterior]]
        except KeyError:
            dict_output[key_name_anterior] = ['removed', dict_anterior[key_name_anterior]]
    for key_name_posterior in dict_posterior:
        if key_name_posterior not in dict_anterior:
            dict_output[key_name_posterior] = ['added', dict_posterior[key_name_posterior]]
    if return_type == 'dict':
        return dict_output
    else:
        comparison_path = get_available_name(SNAPSHOT_COMPARISON_DIRECTORY, COMPARISON_NAME)
        with open(comparison_path, 'w') as last_comparison:
            json.dump(dict_output, last_comparison, indent=4)
        log(f'snapshot comparison saved to {comparison_path}')
        return comparison_path


def initiate_comparison(module_directory, start_module='', changes_source='directory'):
    """
    Creates a change list for a module definition, based on provided data.
    :param module_directory: path to the module, whose definition is being created
    :param start_module: path to the present game folder to base the change on
    :param changes_source: 'directory' | 'comparison' | 'snapshot' -
    If 'directory', bases the changes on a present game folder.
    If 'comparison', bases the changes on a comparison file.
    If 'snapshot', bases the changes on the difference between present files and files in the snapshot.
    :return: tuple(active, changes)
    """
    if not start_module and changes_source == 'directory':
        start_module = askdirectory(title=f'{s.PROGRAM_NAME}: select the game directory to define the mod',
                                    initialdir=s.MAIN_DIRECTORY)
    if os.path.isdir(module_directory):
        changes = {}
        active = False
        if os.path.isdir(changes_source):
            active = True
            snapshot_take(
                game_paths=[changes_source.split('/')[-1]], return_type='path', name=changes_source.split('/')[-1])
            current_files = hash_directory(changes_source)
            for new_file in current_files:
                if len(new_file) > 0:
                    changes[new_file] = ['new', current_files[new_file]]
        elif changes_source == 'directory':
            new_folders_list = [f'{module_directory}/{_}' for _ in os.listdir(module_directory)
                                if os.path.isdir(f'{module_directory}/{_}')]
            new_files_dict = {}
            for new_folder in new_folders_list:
                new_files_dict.update(hash_directory(new_folder, path_to_omit=f'{module_directory}'))
            if start_module and new_files_dict:
                active = False
                current_files = hash_directory(
                    start_module, path_to_omit=f'{start_module[:start_module.rfind("/")]}')
                for new_file in new_files_dict:
                    if new_file in current_files:
                        changes[new_file] = ['changed', new_files_dict[new_file], current_files[new_file]]
                    else:
                        changes[new_file] = ['added', new_files_dict[new_file]]
            elif start_module and not new_files_dict:
                active = True
                current_files = hash_directory(start_module)
                for new_file in current_files:
                    changes[new_file] = ['added', current_files[new_file]]
            files_to_remove = askopenfilenames(title=f'{s.PROGRAM_NAME}: select files to remove',
                                               initialdir=s.MAIN_DIRECTORY)
            for file_path in files_to_remove:
                changes[file_path] = ['removed', hash_file(file_path)]
            snapshot_take(
                    game_paths=[module_directory], name=module_directory.split('/')[-1])
        elif changes_source == 'comparison':
            selected_comparison = askopenfilename(
                title=f'{s.PROGRAM_NAME}: select the snapshot comparison to define the mod',
                initialdir=f'./{SNAPSHOT_COMPARISON_DIRECTORY}')
            if os.path.isfile(selected_comparison):
                with open(selected_comparison) as comparison_buffer:
                    comparison_dict = json.load(comparison_buffer)
                for path_key in comparison_dict:
                    if comparison_dict[path_key][0] != 'unchanged':
                        changes[path_key] = comparison_dict[path_key]
                active = True
            else:
                raise s.InternalError('comparison not selected')
        elif changes_source == 'snapshot':
            selected_snapshot = askopenfilename(
                title=f'{s.PROGRAM_NAME}: select the snapshot taken before the changes',
                initialdir=f'./{SNAPSHOT_DIRECTORY}')
            if os.path.isfile(selected_snapshot):
                with open(selected_snapshot) as snapshot_buffer:
                    snapshot_dict = json.load(snapshot_buffer)
                game_paths = []
                for path_key in snapshot_dict:
                    if path_key == 'date':
                        continue
                    elif path_key.replace('\\', '/').split('/')[1] not in game_paths:
                        game_paths.append(path_key.replace('\\', '/').split('/')[1])
                new_snapshot = snapshot_take(
                    game_paths=game_paths, return_type='text save', name=module_directory.split('/')[-1])
                comparison_dict = snapshot_compare(selected_snapshot, new_snapshot.split('\n'), return_type='lines')
                for path_key in comparison_dict:
                    if comparison_dict[path_key][0] != 'unchanged' and path_key != 'date_1' and path_key != 'date_2':
                        changes[path_key] = comparison_dict[path_key]
                active = True
            else:
                raise s.InternalError('snapshot not selected')
        log(f'comparison generated for {module_directory}')
        return active, changes
    else:
        raise s.InternalError('provided directory is not correct')


test_previous_src = ''
test_previous_dst = ''
test_previous_type = ''
error_sensitivity = True


def test_transfer(src, dst='', transfer='copy', error_sensitive=True):
    """
    If TEST == True, reports if the file can be transferred, else tries to transfer the file from source to destination.
    :param src: path of the file to transfer
    :param dst: path of the directory to transfer to
    :param transfer: 'copy' | 'move' | 'delete' - transfer type.
    :param error_sensitive: if True, stops if an error is detected.
    :return: text gathering the report of the transfer.
    """
    global test_previous_src, test_previous_dst, test_previous_type, error_sensitivity
    output = ''
    if TEST:
        if os.path.exists(src):
            if transfer == 'delete':
                output += log(f'for deletion: {src}')
                if not os.path.isfile(f"{dst}/{src.split('/')[-1]}"):
                    output += log(f"warning: original absent {dst}/{src.split('/')[-1]}")
            else:
                output += log(f'source: {src}')
        else:
            output += log(f'error: source absent {src}')
        if dst and transfer != 'delete':
            if os.path.exists(dst):
                if os.path.isfile(f"{dst}/{src.split('/')[-1]}") and test_previous_src == f"{dst}/{src.split('/')[-1]}":
                    if test_previous_type == 'delete':
                        output += log(f'information: destination {test_previous_src} deleted')
                    elif test_previous_type == 'move':
                        output += log(f'destination: {dst} (correct)')
                    else:
                        output += log(f"warning: destination present {dst}/{src.split('/')[-1]}")
                else:
                    output += log(f'destination: {dst}')
            else:
                output += log(f'error: destination absent {dst}')
        test_previous_src, test_previous_dst, test_previous_type = src, dst, transfer
    else:
        try:
            if transfer == 'copy':
                ensure_path_exists(src, )
                copy2(src, dst)
            elif transfer == 'move':
                move(src, dst)
            elif transfer == 'delete':
                os.remove(src)
        except OSError as err:
            if src.endswith('.bak'):
                new_src = src.replace('.bak', '')
                return test_transfer(new_src, dst, transfer, error_sensitive)
            elif src.endswith('.disabled'):
                new_src = src.replace('.disabled', '.big')
                return test_transfer(new_src, dst, transfer, error_sensitive)
            elif src.endswith('.big'):
                if os.path.isfile(f'{src}.bak'):
                    return test_transfer(f'{src}.bak', dst, transfer, error_sensitive)
                elif os.path.isfile(f'{src.replace('.big', '.disabled')}'):
                    return test_transfer(f'{src.replace('.big', '.disabled')}', dst, transfer, error_sensitive)
            if error_sensitive:
                # TODO later: own message box - a self-explanatory one
                do_proceed = tkinter.messagebox.askyesnocancel(
                    title=f'{s.PROGRAM_NAME}: error',
                    message=f'Error with {src}\n{err.strerror if err.strerror else ' - '}\n'
                    'Click "Yes" to continue displaying each error and to proceed.\n'
                    'Click "No" to skip all errors and to proceed.\n'
                    'Click "Cancel" to stop and revert the changes made'
                )
                if do_proceed is True:
                    pass
                elif do_proceed is False:
                    error_sensitivity = False
                elif do_proceed is None:
                    raise s.InternalError(err.strerror)
    return output


def ensure_path_exists(file_path, check_path='..'):
    """ Creates the directories in the ARCHIVE and LIBRARY folders where the files will be transferred. """
    # # # 'if' added for case of test_transfer - copy.
    if s.LIBRARY in file_path:
        check_path = '/'.join(file_path.split('/')[:s.LIBRARY.count('/') + 2])
        file_path = file_path[file_path.index(check_path) + len(check_path) + 1:]
    if not os.path.exists(check_path):
        os.makedirs(check_path, exist_ok=True)
    path_folders = file_path.split('/')
    file_path_part = ''
    for file_folder in path_folders[1:-1]:
        file_path_part += f'/{file_folder}'
        if not os.path.exists(f'{check_path}{file_path_part}'):
            os.mkdir(f'{check_path}{file_path_part}')


def check_library(module_object):
    changes = module_object['changes']
    library_missing = False
    for file in changes:
        if not os.path.isfile(file.replace('../', f"{s.LIBRARY}/{module_object['name']}/")):
            library_missing = True
    return library_missing


# TODO: check
def module_reverse(module_object=None, module_name='', transfer='copy', comparison_path='', last_snapshot=None,
                   check_type='definition'):
    """
    Detaches the module from the game directory, by retrieving all its files to the LIBRARY.
    :param module_object: (optional) the dictionary-based Definition object
    :param module_name: (optional) the name of the module to detach
    :param transfer: 'copy' | 'move' | 'delete' - transfer type.
    :param comparison_path: (optional) path to a comparison file on which the changes will be based.
    :param last_snapshot: (optional) path to a snapshot file on which the changes will be based.
    :param check_type: 'definition' | 'snapshot' | 'pass' - check if the module is indeed in the game folder
    If 'definition', checks the files enlisted in the changes of the definition file.
     Also checks and detaches if necessary any modules depending on this one.
    If 'snapshot', checks the files compared to the values in a given snapshot file.
    If 'pass', does not check, just tries to detach what it can.
    :return: logs about the transfer details.
    """
    global error_sensitivity
    comparison_lines = []
    if module_object:
        module_name = module_object['name']
        changes = module_object['changes']
        for change_file in changes:
            comparison_lines.append(change_file.replace('\\', '/') + f'\t{changes[change_file]}\n')
    if not os.path.isdir(f'{s.LIBRARY}/{module_name}'):
        os.mkdir(f'{s.LIBRARY}/{module_name}')
    module_directory = f'{s.LIBRARY}/{module_name}'
    if os.path.isfile(f"{module_directory}/{COMPARISON_NAME}{module_name}.txt"):
        comparison_path = f"{module_directory}/{COMPARISON_NAME}{module_name}.txt"
    if transfer == 'remove':
        try:
            if module_object is None:
                module_object = definition_read(module_path=module_directory)
        except s.InternalError as error:
            raise error
        if module_object['active'] is False and check_type != 'pass':
            raise s.InternalError('deactivation of inactive module aborted')
        if module_object['class'] == DEFINITION_CLASSES[0]:
            transfer = 'move'
        elif module_object['class'] == DEFINITION_CLASSES[1] and check_library(module_object):
            transfer = 'move'
        elif module_object['class'] == DEFINITION_CLASSES[1]:
            transfer = 'delete'
    if transfer == 'move' or transfer == 'delete':
        try:
            override = module_detect_changes(module_directory=module_directory)
        except s.InternalError as error:
            raise error
        if override:
            raise s.InternalError('changes have been made to the module file')
            # TODO later: if changes, propose to save them
    if not comparison_path and not comparison_lines:
        if last_snapshot is None:
            selected_file = askopenfilename(title=f'{s.PROGRAM_NAME}: select a snapshot or a comparison file',
                                            initialdir=SNAPSHOT_DIRECTORY)
            if selected_file.split('/')[-1].startswith(COMPARISON_NAME):
                comparison_path = selected_file
            elif selected_file.split('/')[-1].startswith('file_snapshot_'):
                last_snapshot = selected_file
        if last_snapshot:
            new_snapshot = snapshot_take(return_type='text')
            comparison_lines = snapshot_compare(last_snapshot, new_snapshot, return_type='lines')
        if not comparison_path:
            raise s.InternalError('comparison missing')
    if os.path.isfile(comparison_path) and not comparison_lines:
        with open(comparison_path) as comparison_file:
            comparison_lines = comparison_file.readlines()
    if not comparison_lines:
        raise s.InternalError('comparison missing')

    error_sensitivity = True
    if check_type == 'snapshot':
        # TODO later: verify prerequisites by making a snapshot and comparing it
        pass
    elif check_type == 'definition':
        if os.path.isfile(f'{module_directory}/{DEFINITION_NAME}'):
            definition_dict = definition_read(module_path=module_directory)
            if definition_dict['heir']:
                heir_directory = f"{'/'.join(module_directory.split('/')[:-1])}/{definition_dict['heir']}"
                if os.path.isfile(f'{heir_directory}/{DEFINITION_NAME}'):
                    heir_definition_dict = definition_read(module_path=heir_directory)
                    if heir_definition_dict['active']:
                        module_reverse(module_name=heir_definition_dict['name'], transfer='remove')
    elif check_type == 'pass':
        error_sensitivity = False
    output = ''
    try:
        for line in comparison_lines:
            path_start = s.MAIN_DIRECTORY.replace('\\', '/').count('/')
            file_path, value = line.strip().split('\t')
            file_path_game = '/'.join(file_path.split('/')[:-1])
            file_path_module = (f"{s.LIBRARY}/{module_name}/"
                                f"{'/'.join(file_path.split('/')[path_start:-1])}")
            file_path_archive = f"{s.ARCHIVE}/{module_name}/{'/'.join(file_path.split('/')[path_start:])}"
            if value == 'unchanged':
                pass
            elif value == 'different':
                if transfer in TRANSFER_TYPES:
                    ensure_path_exists(file_path, f'{s.LIBRARY}/{module_name}')
                    output += test_transfer(file_path, file_path_module, transfer, error_sensitivity)
                if transfer == 'move' or transfer == 'delete':
                    ensure_path_exists(file_path, f'{s.ARCHIVE}/{module_name}')
                    output += test_transfer(file_path_archive, file_path_game, 'move', error_sensitivity)
            elif value == 'new':
                ensure_path_exists(file_path, f'{s.LIBRARY}/{module_name}')
                try:
                    output += test_transfer(file_path, file_path_module, transfer, error_sensitivity)
                except FileExistsError:
                    pass
            elif value == 'removed':
                if transfer == 'move' or transfer == 'delete':
                    ensure_path_exists(file_path, f'{s.ARCHIVE}/{module_name}')
                    output += test_transfer(file_path_archive, file_path_game, 'move', error_sensitivity)
                else:
                    pass
    except s.InternalError:
        return module_attach(module_directory=module_directory, check_type='pass')
    if TEST:
        raise s.InternalError('under TEST phase: module_reverse not applied')
    definition_edit(definition_object=module_object, active=False)
    return log(f'module_reverse {module_name}\n{output}')


# TODO: check
def module_attach(module_object=None, module_directory=None, check_type='definition'):
    """
    Attaches a module to the game directory.
    :param module_object: (optional) dictionary-based module object
    :param module_directory: (optional) path of the module to attach
    :param check_type: 'definition' | 'snapshot' | 'pass' - check if the module is indeed in the LIBRARY folder
    If 'definition', checks the files enlisted in the changes of the definition file.
     Also checks and attaches if necessary any modules required to this one.
    If 'snapshot', checks the files compared to the values in a given snapshot file.
    If 'pass', does not check, just tries to attach what it can.
    :return: logs about the transfer details.
    """
    global error_sensitivity
    transfer = 'move'
    if module_object is None:
        if module_directory is None:
            module_directory = askdirectory(title=f'{s.PROGRAM_NAME}: select module directory',
                                            initialdir=s.LIBRARY)
            if not module_directory:
                raise s.InternalError('module directory missing')
        if os.path.isfile(f'{module_directory}/{DEFINITION_NAME}'):
            module_object = definition_read(module_path=module_directory)
    error_sensitivity = True
    if check_type == 'snapshot':
        # TODO later: verify prerequisites by making a snapshot and comparing it
        pass
    elif check_type == 'definition':
        if os.path.isdir(module_object['path']):
            module_directory = module_object['path']
        elif os.path.isdir(f"{s.LIBRARY}/{module_object['name']}"):
            module_directory = f"{s.LIBRARY}/{module_object['name']}"
        else:
            raise s.InternalError('path not recognized')
        if module_object['active'] is True and check_type != 'pass':
            raise s.InternalError('activation of active module aborted')
        if module_object['class'] == DEFINITION_CLASSES[0]:
            transfer = 'move'
        elif module_object['class'] == DEFINITION_CLASSES[1]:
            transfer = 'copy'
        if module_object['ancestor']:
            ancestor_directory = f"{'/'.join(module_directory.split('/')[:-1])}/{module_object['ancestor']}"
            if os.path.isfile(f'{ancestor_directory}/{DEFINITION_NAME}'):
                ancestor_definition_dict = definition_read(module_path=ancestor_directory)
                if not ancestor_definition_dict['active']:
                    module_attach(module_directory=ancestor_directory)
    elif check_type == 'pass':
        error_sensitivity = False
    module_name = module_directory.split('/')[-1]
    if not os.path.isdir(f'{s.ARCHIVE}/{module_name}'):
        os.mkdir(f'{s.ARCHIVE}/{module_name}')
    comparison_lines = []
    try:
        changes = module_object['changes']
        for change_file in changes:
            comparison_lines.append(change_file.replace('\\', '/') + f'\t{changes[change_file]}\n')
    except s.InternalError:
        pass
    if not comparison_lines and os.path.isfile(f"{module_directory}/{COMPARISON_NAME}{module_name}.txt"):
        with open(f"{module_directory}/{COMPARISON_NAME}{module_name}.txt") as comparison_buffer:
            comparison_lines = comparison_buffer.readlines()
    if comparison_lines:
        try:
            output = ''
            path_start = s.MAIN_DIRECTORY.count('/')
            for line in comparison_lines:
                try:
                    file_path, value = line.strip().split('\t')
                except ValueError:
                    raise s.InternalError('module_attach: valueError')
                file_path_game = '/'.join(file_path.split('/')[:-1])
                file_path_archive = (f"{s.ARCHIVE}/{module_name}/"
                                     f"{'/'.join(file_path.split('/')[path_start:-1])}")
                file_path_module = (f"{s.LIBRARY}/{module_name}/"
                                    f"{'/'.join(file_path.split('/')[path_start:])}")
                if value == 'unchanged':
                    pass
                elif value == 'different':
                    ensure_path_exists(file_path)
                    ensure_path_exists(file_path, f'{s.ARCHIVE}/{module_name}')
                    output += test_transfer(file_path, file_path_archive, transfer, error_sensitivity)
                    output += test_transfer(file_path_module, file_path_game, transfer, error_sensitivity)
                elif value == 'new':
                    ensure_path_exists(file_path)
                    output += test_transfer(file_path_module, file_path_game, transfer, error_sensitivity)
                elif value == 'removed':
                    ensure_path_exists(file_path)
                    output += test_transfer(file_path, file_path_archive, transfer, error_sensitivity)
        except s.InternalError:
            return module_reverse(module_object=module_object, transfer='remove', check_type='pass')
    else:
        raise s.InternalError('module_attach: comparison missing')
    if TEST:
        raise s.InternalError('Test phase: module_attach not applied')
    definition_edit(definition_object=module_object, active=True)
    return log(f'module_attach {module_name}\n{output}')


def module_new(name: str, changes_source: str = ''):
    if not os.path.isdir(f'{s.LIBRARY}/{name}'):
        os.mkdir(f'{s.LIBRARY}/{name}')
    output = f'{name} created. \n'
    definition_write(module_directory=f'{s.LIBRARY}/{name}', return_type='save',
                     changes_source=changes_source)
    return log(output)


# may not be needed
def module_copy(new_name, template_directory=None, changes_source=None):
    """
    Copies modules files into a new directory.
    :param new_name: the name of the module to create
    :param template_directory: the path to the module to copy
    :param changes_source: 'snapshot' | 'comparison' | 'directory' - passes the value to definition_write
    :return: logs about the details of the transfer
    """
    if not template_directory:
        raise s.InternalError('template not selected')
    all_modules_names = modules_filter(return_type='names')
    if new_name in all_modules_names:
        raise s.InternalError('module_copy error: name already in use')
    os.mkdir(f'{s.LIBRARY}/{new_name}')
    output = f'{new_name} created. \n'
    folders = []
    files = []
    items_list = os.listdir(template_directory)
    for item in items_list:
        if os.path.isdir(f'{template_directory}/{item}'):
            folders.append(f'{s.LIBRARY}/{new_name}/{item}')
            for next_item in os.listdir(f'{template_directory}/{item}'):
                items_list.append(f'{item}/{next_item}')
                if os.path.isdir(f'{template_directory}/{item}/{next_item}'):
                    folders.append(f'{s.LIBRARY}/{new_name}/{item}/{next_item}')
        elif os.path.isfile(f'{template_directory}/{item}'):
            files.append(item)
        else:
            output += f'warning: item {item} is neither a file nor folder \n'
    if not folders and not files:
        pass
    for folder in folders:
        if not os.path.isdir(folder):
            os.makedirs(folder)
            output += folder + '\n'
    for file in files:
        if file == DEFINITION_NAME:
            definition_write(module_directory=f'{s.LIBRARY}/{new_name}', return_type='save',
                             changes_source=changes_source)
            continue
        copied_file = f'{template_directory}/{file}'
        try:
            test_transfer(copied_file, f'{s.LIBRARY}/{new_name}/{file}', 'copy')
            output += f'{s.LIBRARY}/{new_name}/{file}\n'
        except FileNotFoundError:
            output += f'warning: {file} permission denied'
        except FileExistsError:
            output += f'warning: {file} FileNotFoundError'
    return log(output)


# rest is checked

def module_detect_changes(module=None):
    """ Inspects if the files of a module have been changed and returns a text where the changes are listed. """
    changes_dict = {}
    if module is None:
        module_directory = askdirectory(title=f'{s.PROGRAM_NAME}: select a module directory',
                                        initialdir=s.LIBRARY)
        if not module_directory:
            raise s.InternalError('module_detect_changes error: no module selected')
        module = definition_read(module_path=module_directory)
    if module:
        if module['active']:
            for module_file in module['changes']:
                if os.path.isfile(f'{s.MAIN_DIRECTORY}/{module_file}'):
                    if module['changes'][module_file][1] == hash_file(f'{s.MAIN_DIRECTORY}/{module_file}'):
                        pass
                    else:
                        changes_dict[module_file] = 'changed'
                else:
                    changes_dict[module_file] = 'removed'
        else:
            module_directory = f'{s.LIBRARY}/{module['name']}'
            for module_file in module['changes']:
                if os.path.isfile(f'{module_directory}/{module_file}'):
                    if module['changes'][module_file][1] == hash_file(f'{module_directory}/{module_file}'):
                        pass
                    else:
                        changes_dict[module_file] = 'changed'
                else:
                    changes_dict[module_file] = 'removed'
    return changes_dict


def modules_filter(return_type='definitions', **criteria):
    """
    Filters the modules definitions by given criteria
    :param return_type: 'definitions' | 'names'
    :param criteria: key - argument pairs, where the keywords are Definition parameters to compare the value against
    :return: Definition objects or module names, according to the return_type.
    """
    game_modules_list = []
    try:
        modules_names = [_ for _ in os.listdir(s.LIBRARY) if _ not in s.current[s.KEY_EXCEPTIONS]]
        for module_name in modules_names:
            module_definition = definition_read(module_path=f'{s.LIBRARY}/{module_name}')
            if (module_definition['class'] == DEFINITION_CLASSES[0]
                    or module_definition['class'] == DEFINITION_CLASSES[1]):
                if criteria:
                    for criteria_key in criteria:
                        if criteria_key in DEFINITION_EXAMPLE:
                            if module_definition[criteria_key] == criteria[criteria_key]:
                                if return_type == 'names':
                                    game_modules_list.append(module_name)
                                elif return_type == 'definitions':
                                    game_modules_list.append(module_definition)
                else:
                    if return_type == 'names':
                        game_modules_list.append(module_name)
                    elif return_type == 'definitions':
                        game_modules_list.append(module_definition)
    except s.InternalError:
        if game_modules_list:
            return game_modules_list
        else:
            raise s.InternalError(f'empty list')
    return game_modules_list


def modules_sort(criteria='ancestor', modules=None):
    """
    Sorts the modules into a dictionary of modules names as keys and their parent as value
    :param criteria:
    :param modules:
    :return:
    """
    if modules is None:
        modules = modules_filter()
    if criteria == 'ancestor':
        sorted_dict = {}
        for module in modules:
            for mod in modules:
                if mod['name'] == module[criteria]:
                    sorted_dict[module['name']] = str(modules.index(mod))
                    break
        return sorted_dict
    else:
        raise s.InternalError(message='unrecognized criteria')


TEST = False
# TEST = True
